# 包管理器的差异

进行 web 开发时，使用包管理器管理项目中的第三方依赖，如今前端的包管理器都有各自其优缺点，本文讲述其差异。

涵盖的包管理器：

- npm
- yarn
- pnpm

## npm

npm 是随 Node.js 诞生的，是最早的包管理器，也是使用人数最多的；早期的 npm 有很多缺点。

- **依赖地狱（Dependency Hell）**：管理依赖的方式是用树状结构存储的，既：

  ```bash
  node_modules/
  ├─ pkg-1/
  │  ├─ node_modules/
  │  │  ├─ pkg-1-1/
  │  │  ├─ pkg-1-2/
  │  │  │  ├─ node_modules/
  │  │  │  │  ├─ pkg-1-2-1/
  ├─ pkg-2/
  ```

  由于前端依赖的互相依赖，这种结构会导致存储路径过长，而在 Windows 操作系统中最长路径为 260 个字符，超过这个限制会导致无法创建、移动或删除文件。这会给依赖管理带来困难。

- **权限问题**：在 Linux 和 macOS 上，早期版本的 npm 默认尝试以 root 用户身份安装全局包，这可能带来安全风险：如果有人向依赖中投毒，那你的电脑会不幸中招。

- **性能问题**：由于 npm 的树状依赖结构，在处理大型项目时可能会变得非常慢。

- **缺乏细粒度控制**：早期 npm 对依赖版本的管理不够精细，缺少像现在这样的^和~符号来指定允许的小版本更新范围，这使得依赖升级变得困难。

- **依赖漂移**：由于 package.json 对版本的控制并不深入，最多控制到次版本，导致还原依赖时可能出现版本不一致，例如：express@4.15.4，还原时可能会被安装为 express@4.15.5 等。

- **peerDependencies（对等依赖）**：对 peer 依赖并不会自动安装，导致尽管一个依赖声明了 peerDependencies，但用户未显示安装，npm 也不会去安装它。

- **全局包版本冲突**：想要使用一些依赖的命令行工具，需要全局安装它，当想要使用它的不同版本时，只能卸载依赖安装固定版本，极为不便利。

随着问题日益严重，Yarn 推出了，npm 的用户迅速流失到 Yarn，后来 npm 的不断迭代升级，已经解决了跟多问题，很多用户也换回了 npm，解决的问题包括：

- npm@3 时将树状结构更改为扁平化结构，只有当存在版本冲突时才会创建嵌套结构。例如：
  ```bash
  node_modules/
  ├─ pkg-1/
  ├─ pkg-1-1/
  ├─ pkg-1-2/
  ├─ pkg-1-2-1/
  ├─ pkg-2/
  ```
- npm@5 推出 package-lock.json，它记录 package.json 里所例举的包的应安装版本，安装地址，校验包完整性的 hash，其需要的子包，以及依赖列表。在还原依赖时，通过 package-lock.json 可以在不同环境下还原出一致的版本，解决了版本漂移的问题。

- npm@5 推出 npx，可以直接通过 npx 运行某个包中的命令，而不需要事先全局安装该包。

- npm@7 自动安装缺失的 peer 依赖，自动安装合适的版本，如果确实存在无法解决的冲突，npm 7 会提供清晰的错误信息。

随着 npm 的不断迭代，依赖管理机制变得更加智能和高效，现在与 yarn 的差距已经不是很大。

## yarn

Yarn 由 Facebook、Exponent、Google 和 Tilde 协力开发，旨在解决 npm 的问题并提供了其它的实用功能

## pnpm
