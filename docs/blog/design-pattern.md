# 设计模式

设计模式可以帮助开发人员更快地解决常见的设计问题，并且可以提高代码的可读性和可维护性。它们能够帮助开发者编写出更加模块化、可重用和易于维护的代码。

选择合适的设计模式需要根据项目的具体需求来定，过度设计或不恰当的应用模式可能会导致代码复杂度增加。

## SOLID 原则

SOLID 是五个首字母缩写的组合，分别代表：

- 单一职责原则（Single Responsibility Principle, SRP）
- 开闭原则（Open/Closed Principle, OCP）
- 里氏替换原则（Liskov Substitution Principle, LSP）
- 接口隔离原则（Interface Segregation Principle, ISP）
- 依赖倒置原则（Dependency Inversion Principle, DIP）

### 单一职责原则

一个类应该只负责一个功能领域，不应该承担多个不相关的职责。这样可以使类更加专注，更容易理解和维护。

### 开闭原则

在不修改现有代码的情况下，通过增加新的代码来扩展系统的功能。这可以通过多态和抽象类来实现。

### 里氏替换原则

子类应该能够无缝地替换基类，而不会影响程序的正确性。这意味着子类应该能够完全实现基类的行为。

### 接口隔离原则

接口应该尽可能小和具体，而不是大而全。这样可以避免客户端被迫实现不必要的方法。

### 依赖倒置原则

高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

## 创建型模式

创建型模式与对象的创建有关，它们试图以一种适合特定情况的方式来创建对象。

### 单例模式

确保一个类只有一个实例，并提供一个全局访问点。

### 简单工厂模式

提供一个创建对象的静态方法，根据传入的参数返回不同的对象实例。

### 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类。

### 抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

## 结构型模式

结构型模式处理类或对象的组合。这些模式有助于设计简单灵活的接口。

### 装饰模式

动态地给一个对象添加一些额外的职责。

### 适配器模式

允许不兼容的接口一起工作。

### 代理模式

为其他对象提供一个代理以控制对这个对象的访问。

## 行为型模式

行为型模式关注于对象之间的通信。它们用于管理算法、关系和责任。

### 观察者模式

当对象的状态改变时，所有依赖于它的对象都会得到通知并自动更新。如 Vue 的响应式系统。

### 发布订阅模式

发布者将消息发布到一个特定的频道，任何订阅了该频道的订阅者都会收到消息。如 Node.js 中的 `EventEmitter` 。

### 模板模式

模板模式定义了一个操作中的算法骨架，而将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下重新定义算法的某些特定步骤。这是一种基于继承的设计模式，主要用于代码复用。

### 策略模式

定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换。

### 迭代器模式

提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
