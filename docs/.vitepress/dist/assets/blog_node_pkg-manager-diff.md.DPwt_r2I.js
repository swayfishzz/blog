import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.BsJ0pqcO.js";const c=JSON.parse('{"title":"包管理器的差异","description":"","frontmatter":{},"headers":[],"relativePath":"blog/node/pkg-manager-diff.md","filePath":"blog/node/pkg-manager-diff.md"}'),p={name:"blog/node/pkg-manager-diff.md"},l=n(`<h1 id="包管理器的差异" tabindex="-1">包管理器的差异 <a class="header-anchor" href="#包管理器的差异" aria-label="Permalink to &quot;包管理器的差异&quot;">​</a></h1><p>进行 web 开发时，使用包管理器管理项目中的第三方依赖，如今前端的包管理器都有各自其优缺点，本文讲述其差异。</p><p>涵盖的包管理器：</p><ul><li>npm</li><li>yarn</li><li>pnpm</li></ul><h2 id="npm" tabindex="-1">npm <a class="header-anchor" href="#npm" aria-label="Permalink to &quot;npm&quot;">​</a></h2><p>npm 是随 Node.js 诞生的，是最早的包管理器，也是使用人数最多的；早期的 npm 有很多缺点。</p><ul><li><p><strong>依赖地狱（Dependency Hell）</strong>：管理依赖的方式是用树状结构存储的，既：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node_modules/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-1/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-1-1/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-1-2/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-1-2-1/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-2/</span></span></code></pre></div><p>由于前端依赖的互相依赖，这种结构会导致存储路径过长，而在 Windows 操作系统中最长路径为 260 个字符，超过这个限制会导致无法创建、移动或删除文件。这会给依赖管理带来困难。</p></li><li><p><strong>权限问题</strong>：在 Linux 和 macOS 上，早期版本的 npm 默认尝试以 root 用户身份安装全局包，这可能带来安全风险：如果有人向依赖中投毒，那你的电脑会不幸中招。</p></li><li><p><strong>性能问题</strong>：由于 npm 的树状依赖结构，在处理大型项目时可能会变得非常慢。</p></li><li><p><strong>缺乏细粒度控制</strong>：早期 npm 对依赖版本的管理不够精细，缺少像现在这样的^和~符号来指定允许的小版本更新范围，这使得依赖升级变得困难。</p></li><li><p><strong>依赖漂移</strong>：由于 package.json 对版本的控制并不深入，最多控制到次版本，导致还原依赖时可能出现版本不一致，例如：express@4.15.4，还原时可能会被安装为 express@4.15.5 等。</p></li><li><p><strong>peerDependencies（对等依赖）</strong>：对 peer 依赖并不会自动安装，导致尽管一个依赖声明了 peerDependencies，但用户未显示安装，npm 也不会去安装它。</p></li><li><p><strong>全局包版本冲突</strong>：想要使用一些依赖的命令行工具，需要全局安装它，当想要使用它的不同版本时，只能卸载依赖安装固定版本，极为不便利。</p></li></ul><p>随着问题日益严重，Yarn 推出了，npm 的用户迅速流失到 Yarn，后来 npm 的不断迭代升级，已经解决了跟多问题，很多用户也换回了 npm，解决的问题包括：</p><ul><li><p>npm@3 时将树状结构更改为扁平化结构，只有当存在版本冲突时才会创建嵌套结构。例如：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node_modules/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-1/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-1-1/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-1-2/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-1-2-1/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├─</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkg-2/</span></span></code></pre></div></li><li><p>npm@5 推出 package-lock.json，它记录 package.json 里所例举的包的应安装版本，安装地址，校验包完整性的 hash，其需要的子包，以及依赖列表。在还原依赖时，通过 package-lock.json 可以在不同环境下还原出一致的版本，解决了版本漂移的问题。</p></li><li><p>npm@5 推出 npx，可以直接通过 npx 运行某个包中的命令，而不需要事先全局安装该包。</p></li><li><p>npm@7 自动安装缺失的 peer 依赖，自动安装合适的版本，如果确实存在无法解决的冲突，npm 7 会提供清晰的错误信息。</p></li></ul><p>随着 npm 的不断迭代，依赖管理机制变得更加智能和高效，现在与 yarn 的差距已经不是很大。</p><h2 id="yarn" tabindex="-1">yarn <a class="header-anchor" href="#yarn" aria-label="Permalink to &quot;yarn&quot;">​</a></h2><p>Yarn 由 Facebook、Exponent、Google 和 Tilde 协力开发，旨在解决 npm 的问题并提供了其它的实用功能</p><h2 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-label="Permalink to &quot;pnpm&quot;">​</a></h2>`,13),e=[l];function t(h,k,r,F,d,o){return a(),i("div",null,e)}const m=s(p,[["render",t]]);export{c as __pageData,m as default};
